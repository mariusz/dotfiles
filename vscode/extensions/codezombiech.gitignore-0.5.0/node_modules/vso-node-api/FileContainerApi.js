/*
* ---------------------------------------------------------
* Copyright(C) Microsoft Corporation. All rights reserved.
* ---------------------------------------------------------
*
* ---------------------------------------------------------
* Generated file, DO NOT EDIT
* ---------------------------------------------------------
*/
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
// Licensed under the MIT license.  See LICENSE file in the project root for full license information.
var stream = require("stream");
var Q = require('q');
var FileContainerApiBase = require("./FileContainerApiBase");
var FileContainerInterfaces = require("./interfaces/FileContainerInterfaces");
var FileContainerApi = (function (_super) {
    __extends(FileContainerApi, _super);
    function FileContainerApi(baseUrl, handlers) {
        _super.call(this, baseUrl, handlers);
    }
    FileContainerApi.prototype.createItem = function (contentStream, uncompressedLength, containerId, itemPath, scope, options) {
        var deferred = Q.defer();
        var chunkStream = new ChunkStream(this, uncompressedLength, containerId, itemPath, scope, options);
        chunkStream.on('finish', function () {
            deferred.resolve(chunkStream.getItem());
        });
        contentStream.pipe(chunkStream);
        return deferred.promise;
    };
    FileContainerApi.prototype._createItem = function (customHeaders, contentStream, containerId, itemPath, scope, onResult) {
        var _this = this;
        var routeValues = {
            containerId: containerId
        };
        var queryValues = {
            itemPath: itemPath,
            scope: scope,
        };
        customHeaders = customHeaders || {};
        customHeaders["Content-Type"] = "application/octet-stream";
        this.vsoClient.getVersioningData("2.2-preview.3", "Container", "e4f5c81e-e250-447b-9fef-bd48471bea5e", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: FileContainerInterfaces.TypeInfo.FileContainerItem, responseIsCollection: false };
            _this.restClient.uploadStream('PUT', url, apiVersion, contentStream, customHeaders, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    return FileContainerApi;
}(FileContainerApiBase.FileContainerApiBase));
exports.FileContainerApi = FileContainerApi;
var ChunkStream = (function (_super) {
    __extends(ChunkStream, _super);
    function ChunkStream(api, uncompressedLength, containerId, itemPath, scope, options) {
        _super.call(this);
        this._buffer = new Buffer(ChunkStream.ChunkSize);
        this._length = 0;
        this._startRange = 0;
        this._bytesToSend = 0;
        this._totalReceived = 0;
        this._api = api;
        this._options = options || {};
        this._uncompressedLength = uncompressedLength;
        this._containerId = containerId;
        this._itemPath = itemPath;
        this._scope = scope;
        this._bytesToSend = this._options.isGzipped ? this._options.compressedLength : uncompressedLength;
    }
    ChunkStream.prototype._write = function (data, encoding, callback) {
        var chunk = data;
        if (!chunk) {
            if (this._length == 0) {
                callback();
            }
            else {
                // last chunk
                this._sendChunk(callback);
            }
            return;
        }
        var newBuffer = null;
        if (this._length + chunk.length > ChunkStream.ChunkSize) {
            // overflow
            var overflowPosition = chunk.length - (ChunkStream.ChunkSize - this._length);
            chunk.copy(this._buffer, this._length, 0, overflowPosition);
            this._length += overflowPosition;
            newBuffer = chunk.slice(overflowPosition);
        }
        else {
            chunk.copy(this._buffer, this._length, 0, chunk.length);
            this._length += chunk.length;
        }
        this._totalReceived += chunk.length;
        if (this._length >= ChunkStream.ChunkSize || this._totalReceived >= this._bytesToSend) {
            this._sendChunk(callback, newBuffer);
        }
        else {
            callback();
        }
    };
    ChunkStream.prototype._sendChunk = function (callback, newBuffer) {
        var _this = this;
        var endRange = this._startRange + this._length;
        var headers = {
            "Content-Range": "bytes " + this._startRange + "-" + (endRange - 1) + "/" + this._bytesToSend,
            "Content-Length": this._length
        };
        if (this._options.isGzipped) {
            headers["Accept-Encoding"] = "gzip";
            headers["Content-Encoding"] = "gzip";
            headers["x-tfs-filelength"] = this._uncompressedLength;
        }
        this._startRange = endRange;
        this._api._createItem(headers, new BufferStream(this._buffer, this._length), this._containerId, this._itemPath, this._scope, function (err, statusCode, item) {
            if (newBuffer) {
                _this._length = newBuffer.length;
                newBuffer.copy(_this._buffer);
            }
            else {
                _this._length = 0;
            }
            _this._item = item;
            callback(err);
        });
    };
    ChunkStream.prototype.getItem = function () {
        return this._item;
    };
    ChunkStream.ChunkSize = (16 * 1024 * 1024);
    return ChunkStream;
}(stream.Writable));
var BufferStream = (function (_super) {
    __extends(BufferStream, _super);
    function BufferStream(buffer, length) {
        _super.call(this);
        this._position = 0;
        this._length = 0;
        this._buffer = buffer;
        this._length = length;
    }
    BufferStream.prototype._read = function (size) {
        if (this._position >= this._length) {
            this.push(null);
            return;
        }
        var end = Math.min(this._position + size, this._length);
        this.push(this._buffer.slice(this._position, end));
        this._position = end;
    };
    return BufferStream;
}(stream.Readable));
