/*
* ---------------------------------------------------------
* Copyright(C) Microsoft Corporation. All rights reserved.
* ---------------------------------------------------------
*
* ---------------------------------------------------------
* Generated file, DO NOT EDIT
* ---------------------------------------------------------
*/
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
// Licensed under the MIT license.  See LICENSE file in the project root for full license information.
var Q = require('q');
var basem = require('./ClientApiBases');
var GitInterfaces = require("./interfaces/GitInterfaces");
var GitApi = (function (_super) {
    __extends(GitApi, _super);
    function GitApi(baseUrl, handlers) {
        _super.call(this, baseUrl, handlers, 'node-Git-api');
    }
    /**
    * Gets a single blob.
    *
    * @param {string} repositoryId
    * @param {string} sha1
    * @param {string} project - Project ID or project name
    * @param {boolean} download
    * @param {string} fileName
    */
    GitApi.prototype.getBlob = function (repositoryId, sha1, project, download, fileName) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, Blob) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Blob);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            sha1: sha1
        };
        var queryValues = {
            download: download,
            fileName: fileName,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "7b28e929-2c99-405d-9c5c-6167a06e6816", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Gets a single blob.
    *
    * @param {string} repositoryId
    * @param {string} sha1
    * @param {string} project - Project ID or project name
    * @param {boolean} download
    * @param {string} fileName
    */
    GitApi.prototype.getBlobContent = function (repositoryId, sha1, project, download, fileName) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, Blob) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Blob);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            sha1: sha1
        };
        var queryValues = {
            download: download,
            fileName: fileName,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "7b28e929-2c99-405d-9c5c-6167a06e6816", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: false };
            _this.httpClient.getStream(url, apiVersion, "application/octet-stream", onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Gets one or more blobs in a zip file download.
    *
    * @param {string[]} blobIds
    * @param {string} repositoryId
    * @param {string} project - Project ID or project name
    * @param {string} filename
    */
    GitApi.prototype.getBlobsZip = function (blobIds, repositoryId, project, filename) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, Blob) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Blob);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            filename: filename,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "7b28e929-2c99-405d-9c5c-6167a06e6816", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: false };
            _this.httpClient.getStream(url, apiVersion, "application/zip", onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Gets a single blob.
    *
    * @param {string} repositoryId
    * @param {string} sha1
    * @param {string} project - Project ID or project name
    * @param {boolean} download
    * @param {string} fileName
    */
    GitApi.prototype.getBlobZip = function (repositoryId, sha1, project, download, fileName) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, Blob) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Blob);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            sha1: sha1
        };
        var queryValues = {
            download: download,
            fileName: fileName,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "7b28e929-2c99-405d-9c5c-6167a06e6816", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: false };
            _this.httpClient.getStream(url, apiVersion, "application/zip", onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Retrieve statistics about a single branch.
    *
    * @param {string} repositoryId - Friendly name or guid of repository
    * @param {string} name - Name of the branch
    * @param {string} project - Project ID or project name
    * @param {GitInterfaces.GitVersionDescriptor} baseVersionDescriptor
    */
    GitApi.prototype.getBranch = function (repositoryId, name, project, baseVersionDescriptor) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, BranchStat) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(BranchStat);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            name: name,
            baseVersionDescriptor: baseVersionDescriptor,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "d5b216de-d8d5-4d32-ae76-51df755b16d3", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitBranchStats, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Retrieve statistics about all branches within a repository.
    *
    * @param {string} repositoryId - Friendly name or guid of repository
    * @param {string} project - Project ID or project name
    * @param {GitInterfaces.GitVersionDescriptor} baseVersionDescriptor
    */
    GitApi.prototype.getBranches = function (repositoryId, project, baseVersionDescriptor) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, BranchStats) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(BranchStats);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            baseVersionDescriptor: baseVersionDescriptor,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "d5b216de-d8d5-4d32-ae76-51df755b16d3", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitBranchStats, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Retrieve statistics for multiple commits
    *
    * @param {GitInterfaces.GitQueryBranchStatsCriteria} searchCriteria
    * @param {string} repositoryId - Friendly name or guid of repository
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.getBranchStatsBatch = function (searchCriteria, repositoryId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, BranchStat) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(BranchStat);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "d5b216de-d8d5-4d32-ae76-51df755b16d3", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: GitInterfaces.TypeInfo.GitQueryBranchStatsCriteria, responseTypeMetadata: GitInterfaces.TypeInfo.GitBranchStats, responseIsCollection: true };
            _this.restClient.create(url, apiVersion, searchCriteria, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Retrieve changes for a particular commit.
    *
    * @param {string} commitId - The id of the commit.
    * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
    * @param {string} project - Project ID or project name
    * @param {number} top - The maximum number of changes to return.
    * @param {number} skip - The number of changes to skip.
    */
    GitApi.prototype.getChanges = function (commitId, repositoryId, project, top, skip) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, Change) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Change);
            }
        };
        var routeValues = {
            project: project,
            commitId: commitId,
            repositoryId: repositoryId
        };
        var queryValues = {
            top: top,
            skip: skip,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "5bf884f5-3e07-42e9-afb8-1b872267bf16", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitCommitChanges, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * @param {GitInterfaces.GitAsyncRefOperationParameters} cherryPickToCreate
    * @param {string} project - Project ID or project name
    * @param {string} repositoryId
    */
    GitApi.prototype.createCherryPick = function (cherryPickToCreate, project, repositoryId) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, CherryPick) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(CherryPick);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "033bad68-9a14-43d1-90e0-59cb8856fef6", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: GitInterfaces.TypeInfo.GitAsyncRefOperationParameters, responseTypeMetadata: GitInterfaces.TypeInfo.GitCherryPick, responseIsCollection: false };
            _this.restClient.create(url, apiVersion, cherryPickToCreate, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * @param {string} project - Project ID or project name
    * @param {number} cherryPickId
    * @param {string} repositoryId
    */
    GitApi.prototype.getCherryPick = function (project, cherryPickId, repositoryId) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, CherryPick) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(CherryPick);
            }
        };
        var routeValues = {
            project: project,
            cherryPickId: cherryPickId,
            repositoryId: repositoryId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "033bad68-9a14-43d1-90e0-59cb8856fef6", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitCherryPick, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * @param {string} project - Project ID or project name
    * @param {string} repositoryId
    * @param {string} refName
    */
    GitApi.prototype.getCherryPickForRefName = function (project, repositoryId, refName) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, CherryPick) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(CherryPick);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            refName: refName,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "033bad68-9a14-43d1-90e0-59cb8856fef6", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitCherryPick, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Retrieve a particular commit.
    *
    * @param {string} commitId - The id of the commit.
    * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
    * @param {string} project - Project ID or project name
    * @param {number} changeCount - The number of changes to include in the result.
    */
    GitApi.prototype.getCommit = function (commitId, repositoryId, project, changeCount) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, Commit) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Commit);
            }
        };
        var routeValues = {
            project: project,
            commitId: commitId,
            repositoryId: repositoryId
        };
        var queryValues = {
            changeCount: changeCount,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "c2570c3b-5b3f-41b8-98bf-5407bfde8d58", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitCommit, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Retrieve git commits for a project
    *
    * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
    * @param {GitInterfaces.GitQueryCommitsCriteria} searchCriteria
    * @param {string} project - Project ID or project name
    * @param {number} skip
    * @param {number} top
    */
    GitApi.prototype.getCommits = function (repositoryId, searchCriteria, project, skip, top) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, Commits) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Commits);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            searchCriteria: searchCriteria,
            '$skip': skip,
            '$top': top,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "c2570c3b-5b3f-41b8-98bf-5407bfde8d58", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitCommitRef, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Retrieve a list of commits associated with a particular push.
    *
    * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
    * @param {number} pushId - The id of the push.
    * @param {string} project - Project ID or project name
    * @param {number} top - The maximum number of commits to return ("get the top x commits").
    * @param {number} skip - The number of commits to skip.
    * @param {boolean} includeLinks
    */
    GitApi.prototype.getPushCommits = function (repositoryId, pushId, project, top, skip, includeLinks) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, Commits) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Commits);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            pushId: pushId,
            top: top,
            skip: skip,
            includeLinks: includeLinks,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "c2570c3b-5b3f-41b8-98bf-5407bfde8d58", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitCommitRef, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Retrieve git commits for a project
    *
    * @param {GitInterfaces.GitQueryCommitsCriteria} searchCriteria - Search options
    * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
    * @param {string} project - Project ID or project name
    * @param {number} skip
    * @param {number} top
    * @param {boolean} includeStatuses
    */
    GitApi.prototype.getCommitsBatch = function (searchCriteria, repositoryId, project, skip, top, includeStatuses) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, CommitsBatch) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(CommitsBatch);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            '$skip': skip,
            '$top': top,
            includeStatuses: includeStatuses,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "6400dfb2-0bcb-462b-b992-5a57f8f1416c", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: GitInterfaces.TypeInfo.GitQueryCommitsCriteria, responseTypeMetadata: GitInterfaces.TypeInfo.GitCommitRef, responseIsCollection: true };
            _this.restClient.create(url, apiVersion, searchCriteria, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Retrieve deleted git repositories.
    *
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.getDeletedRepositories = function (project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, DeletedRepositories) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(DeletedRepositories);
            }
        };
        var routeValues = {
            project: project
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "2b6869c4-cb25-42b5-b7a3-0d3e6be0a11a", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitDeletedRepository, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Create an import request
    *
    * @param {GitInterfaces.GitImportRequest} importRequest
    * @param {string} project - Project ID or project name
    * @param {string} repositoryId
    * @param {boolean} validateParameters
    */
    GitApi.prototype.createImportRequest = function (importRequest, project, repositoryId, validateParameters) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, ImportRequest) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(ImportRequest);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            validateParameters: validateParameters,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "01828ddc-3600-4a41-8633-99b3a73a0eb3", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: GitInterfaces.TypeInfo.GitImportRequest, responseTypeMetadata: GitInterfaces.TypeInfo.GitImportRequest, responseIsCollection: false };
            _this.restClient.create(url, apiVersion, importRequest, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Retrieve a particular import request
    *
    * @param {string} project - Project ID or project name
    * @param {string} repositoryId
    * @param {number} importRequestId
    */
    GitApi.prototype.getImportRequest = function (project, repositoryId, importRequestId) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, ImportRequest) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(ImportRequest);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            importRequestId: importRequestId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "01828ddc-3600-4a41-8633-99b3a73a0eb3", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitImportRequest, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Retrieve import requests for a repository
    *
    * @param {string} project - Project ID or project name
    * @param {string} repositoryId
    * @param {boolean} includeAbandoned
    */
    GitApi.prototype.queryImportRequests = function (project, repositoryId, includeAbandoned) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, ImportRequests) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(ImportRequests);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            includeAbandoned: includeAbandoned,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "01828ddc-3600-4a41-8633-99b3a73a0eb3", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitImportRequest, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Update an import request
    *
    * @param {GitInterfaces.GitImportRequest} importRequestToUpdate
    * @param {string} project - Project ID or project name
    * @param {string} repositoryId
    * @param {number} importRequestId
    */
    GitApi.prototype.updateImportRequest = function (importRequestToUpdate, project, repositoryId, importRequestId) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, ImportRequest) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(ImportRequest);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            importRequestId: importRequestId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "01828ddc-3600-4a41-8633-99b3a73a0eb3", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: GitInterfaces.TypeInfo.GitImportRequest, responseTypeMetadata: GitInterfaces.TypeInfo.GitImportRequest, responseIsCollection: false };
            _this.restClient.update(url, apiVersion, importRequestToUpdate, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Get Item Metadata and/or Content for a single item. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content which is always returned as a download.
    *
    * @param {string} repositoryId
    * @param {string} path
    * @param {string} project - Project ID or project name
    * @param {string} scopePath
    * @param {GitInterfaces.VersionControlRecursionType} recursionLevel
    * @param {boolean} includeContentMetadata
    * @param {boolean} latestProcessedChange
    * @param {boolean} download
    * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor
    */
    GitApi.prototype.getItem = function (repositoryId, path, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, versionDescriptor) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, Item) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Item);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            path: path,
            scopePath: scopePath,
            recursionLevel: recursionLevel,
            includeContentMetadata: includeContentMetadata,
            latestProcessedChange: latestProcessedChange,
            download: download,
            versionDescriptor: versionDescriptor,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "fb93c0db-47ed-4a31-8c20-47552878fb44", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitItem, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Get Item Metadata and/or Content for a single item. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content which is always returned as a download.
    *
    * @param {string} repositoryId
    * @param {string} path
    * @param {string} project - Project ID or project name
    * @param {string} scopePath
    * @param {GitInterfaces.VersionControlRecursionType} recursionLevel
    * @param {boolean} includeContentMetadata
    * @param {boolean} latestProcessedChange
    * @param {boolean} download
    * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor
    */
    GitApi.prototype.getItemContent = function (repositoryId, path, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, versionDescriptor) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, Item) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Item);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            path: path,
            scopePath: scopePath,
            recursionLevel: recursionLevel,
            includeContentMetadata: includeContentMetadata,
            latestProcessedChange: latestProcessedChange,
            download: download,
            versionDescriptor: versionDescriptor,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "fb93c0db-47ed-4a31-8c20-47552878fb44", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: false };
            _this.httpClient.getStream(url, apiVersion, "application/octet-stream", onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Get Item Metadata and/or Content for a collection of items. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content which is always returned as a download.
    *
    * @param {string} repositoryId
    * @param {string} project - Project ID or project name
    * @param {string} scopePath
    * @param {GitInterfaces.VersionControlRecursionType} recursionLevel
    * @param {boolean} includeContentMetadata
    * @param {boolean} latestProcessedChange
    * @param {boolean} download
    * @param {boolean} includeLinks
    * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor
    */
    GitApi.prototype.getItems = function (repositoryId, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, includeLinks, versionDescriptor) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, Items) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Items);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            scopePath: scopePath,
            recursionLevel: recursionLevel,
            includeContentMetadata: includeContentMetadata,
            latestProcessedChange: latestProcessedChange,
            download: download,
            includeLinks: includeLinks,
            versionDescriptor: versionDescriptor,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "fb93c0db-47ed-4a31-8c20-47552878fb44", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitItem, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Get Item Metadata and/or Content for a single item. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content which is always returned as a download.
    *
    * @param {string} repositoryId
    * @param {string} path
    * @param {string} project - Project ID or project name
    * @param {string} scopePath
    * @param {GitInterfaces.VersionControlRecursionType} recursionLevel
    * @param {boolean} includeContentMetadata
    * @param {boolean} latestProcessedChange
    * @param {boolean} download
    * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor
    */
    GitApi.prototype.getItemText = function (repositoryId, path, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, versionDescriptor) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, Item) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Item);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            path: path,
            scopePath: scopePath,
            recursionLevel: recursionLevel,
            includeContentMetadata: includeContentMetadata,
            latestProcessedChange: latestProcessedChange,
            download: download,
            versionDescriptor: versionDescriptor,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "fb93c0db-47ed-4a31-8c20-47552878fb44", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: false };
            _this.httpClient.getStream(url, apiVersion, "text/plain", onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Get Item Metadata and/or Content for a single item. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content which is always returned as a download.
    *
    * @param {string} repositoryId
    * @param {string} path
    * @param {string} project - Project ID or project name
    * @param {string} scopePath
    * @param {GitInterfaces.VersionControlRecursionType} recursionLevel
    * @param {boolean} includeContentMetadata
    * @param {boolean} latestProcessedChange
    * @param {boolean} download
    * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor
    */
    GitApi.prototype.getItemZip = function (repositoryId, path, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, versionDescriptor) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, Item) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Item);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            path: path,
            scopePath: scopePath,
            recursionLevel: recursionLevel,
            includeContentMetadata: includeContentMetadata,
            latestProcessedChange: latestProcessedChange,
            download: download,
            versionDescriptor: versionDescriptor,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "fb93c0db-47ed-4a31-8c20-47552878fb44", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: false };
            _this.httpClient.getStream(url, apiVersion, "application/zip", onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Post for retrieving a creating a batch out of a set of items in a repo / project given a list of paths or a long path
    *
    * @param {GitInterfaces.GitItemRequestData} requestData
    * @param {string} repositoryId
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.getItemsBatch = function (requestData, repositoryId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, ItemsBatch) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(ItemsBatch);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "630fd2e4-fb88-4f85-ad21-13f3fd1fbca9", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: GitInterfaces.TypeInfo.GitItemRequestData, responseTypeMetadata: GitInterfaces.TypeInfo.GitItem, responseIsCollection: true };
            _this.restClient.create(url, apiVersion, requestData, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Get the commits for an iteration.
    *
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {number} iterationId - Iteration to retrieve commits for
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.getPullRequestIterationCommits = function (repositoryId, pullRequestId, iterationId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequestCommits) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestCommits);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId,
            iterationId: iterationId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "e7ea0883-095f-4926-b5fb-f24691c26fb9", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitCommitRef, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Retrieve pull request's commits
    *
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.getPullRequestCommits = function (repositoryId, pullRequestId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequestCommits) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestCommits);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "52823034-34a8-4576-922c-8d8b77e9e4c4", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitCommitRef, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Retrieve one conflict for a pull request by ID
    *
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {number} conflictId
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.getPullRequestConflict = function (repositoryId, pullRequestId, conflictId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequestConflict) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestConflict);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId,
            conflictId: conflictId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "d840fb74-bbef-42d3-b250-564604c054a4", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitConflict, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Retrieve all conflicts for a pull request
    *
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {string} project - Project ID or project name
    * @param {number} skip
    * @param {number} top
    * @param {boolean} includeObsolete
    */
    GitApi.prototype.getPullRequestConflicts = function (repositoryId, pullRequestId, project, skip, top, includeObsolete) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequestConflicts) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestConflicts);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId
        };
        var queryValues = {
            '$skip': skip,
            '$top': top,
            includeObsolete: includeObsolete,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "d840fb74-bbef-42d3-b250-564604c054a4", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitConflict, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Update merge conflict resolution
    *
    * @param {GitInterfaces.GitConflict} conflict
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {number} conflictId
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.updatePullRequestConflict = function (conflict, repositoryId, pullRequestId, conflictId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequestConflict) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestConflict);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId,
            conflictId: conflictId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "d840fb74-bbef-42d3-b250-564604c054a4", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: GitInterfaces.TypeInfo.GitConflict, responseTypeMetadata: GitInterfaces.TypeInfo.GitConflict, responseIsCollection: false };
            _this.restClient.update(url, apiVersion, conflict, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {number} iterationId
    * @param {string} project - Project ID or project name
    * @param {number} top
    * @param {number} skip
    * @param {number} compareTo
    */
    GitApi.prototype.getPullRequestIterationChanges = function (repositoryId, pullRequestId, iterationId, project, top, skip, compareTo) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequestIterationChange) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestIterationChange);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId,
            iterationId: iterationId
        };
        var queryValues = {
            '$top': top,
            '$skip': skip,
            '$compareTo': compareTo,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "4216bdcf-b6b1-4d59-8b82-c34cc183fc8b", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitPullRequestIterationChanges, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {number} iterationId
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.getPullRequestIteration = function (repositoryId, pullRequestId, iterationId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequestIteration) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestIteration);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId,
            iterationId: iterationId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "d43911ee-6958-46b0-a42b-8445b8a0d004", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitPullRequestIteration, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {string} project - Project ID or project name
    * @param {boolean} includeCommits
    */
    GitApi.prototype.getPullRequestIterations = function (repositoryId, pullRequestId, project, includeCommits) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequestIterations) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestIterations);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId
        };
        var queryValues = {
            includeCommits: includeCommits,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "d43911ee-6958-46b0-a42b-8445b8a0d004", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitPullRequestIteration, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Query for pull requests
    *
    * @param {GitInterfaces.GitPullRequestQuery} queries
    * @param {string} repositoryId
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.getPullRequestQuery = function (queries, repositoryId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequestQuery) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestQuery);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "b3a6eebe-9cf0-49ea-b6cb-1a4c5f5007b0", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: GitInterfaces.TypeInfo.GitPullRequestQuery, responseTypeMetadata: GitInterfaces.TypeInfo.GitPullRequestQuery, responseIsCollection: false };
            _this.restClient.create(url, apiVersion, queries, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Adds a reviewer to a git pull request
    *
    * @param {GitInterfaces.IdentityRefWithVote} reviewer
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {string} reviewerId
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.createPullRequestReviewer = function (reviewer, repositoryId, pullRequestId, reviewerId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequestReviewer) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestReviewer);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId,
            reviewerId: reviewerId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "4b6702c7-aa35-4b89-9c96-b9abf6d3e540", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: false };
            _this.restClient.replace(url, apiVersion, reviewer, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Adds reviewers to a git pull request
    *
    * @param {VSSInterfaces.IdentityRef[]} reviewers
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.createPullRequestReviewers = function (reviewers, repositoryId, pullRequestId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequestReviewers) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestReviewers);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "4b6702c7-aa35-4b89-9c96-b9abf6d3e540", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: true };
            _this.restClient.create(url, apiVersion, reviewers, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Adds reviewers to a git pull request
    *
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {string} reviewerId
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.deletePullRequestReviewer = function (repositoryId, pullRequestId, reviewerId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(null);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId,
            reviewerId: reviewerId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "4b6702c7-aa35-4b89-9c96-b9abf6d3e540", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: false };
            _this.restClient.delete(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode);
        });
        return deferred.promise;
    };
    /**
    * Retrieve a reviewer from a pull request
    *
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {string} reviewerId
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.getPullRequestReviewer = function (repositoryId, pullRequestId, reviewerId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequestReviewer) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestReviewer);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId,
            reviewerId: reviewerId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "4b6702c7-aa35-4b89-9c96-b9abf6d3e540", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Retrieve a pull request reviewers
    *
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.getPullRequestReviewers = function (repositoryId, pullRequestId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequestReviewers) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestReviewers);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "4b6702c7-aa35-4b89-9c96-b9abf6d3e540", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Get a pull request using it's ID
    *
    * @param {number} pullRequestId - the Id of the pull request
    */
    GitApi.prototype.getPullRequestById = function (pullRequestId) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequest) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequest);
            }
        };
        var routeValues = {
            pullRequestId: pullRequestId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "01a46dea-7d46-4d40-bc84-319e7c260d99", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitPullRequest, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Query pull requests by project
    *
    * @param {string} project - Project ID or project name
    * @param {GitInterfaces.GitPullRequestSearchCriteria} searchCriteria
    * @param {number} maxCommentLength
    * @param {number} skip
    * @param {number} top
    */
    GitApi.prototype.getPullRequestsByProject = function (project, searchCriteria, maxCommentLength, skip, top) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequests) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequests);
            }
        };
        var routeValues = {
            project: project
        };
        var queryValues = {
            searchCriteria: searchCriteria,
            maxCommentLength: maxCommentLength,
            '$skip': skip,
            '$top': top,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "a5d28130-9cd2-40fa-9f08-902e7daa9efb", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitPullRequest, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Create a git pull request
    *
    * @param {GitInterfaces.GitPullRequest} gitPullRequestToCreate
    * @param {string} repositoryId
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.createPullRequest = function (gitPullRequestToCreate, repositoryId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequest) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequest);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "9946fd70-0d40-406e-b686-b4744cbbcc37", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: GitInterfaces.TypeInfo.GitPullRequest, responseTypeMetadata: GitInterfaces.TypeInfo.GitPullRequest, responseIsCollection: false };
            _this.restClient.create(url, apiVersion, gitPullRequestToCreate, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Retrieve a pull request
    *
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {string} project - Project ID or project name
    * @param {number} maxCommentLength
    * @param {number} skip
    * @param {number} top
    * @param {boolean} includeCommits
    * @param {boolean} includeWorkItemRefs
    */
    GitApi.prototype.getPullRequest = function (repositoryId, pullRequestId, project, maxCommentLength, skip, top, includeCommits, includeWorkItemRefs) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequest) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequest);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId
        };
        var queryValues = {
            maxCommentLength: maxCommentLength,
            '$skip': skip,
            '$top': top,
            includeCommits: includeCommits,
            includeWorkItemRefs: includeWorkItemRefs,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "9946fd70-0d40-406e-b686-b4744cbbcc37", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitPullRequest, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Query for pull requests
    *
    * @param {string} repositoryId
    * @param {GitInterfaces.GitPullRequestSearchCriteria} searchCriteria
    * @param {string} project - Project ID or project name
    * @param {number} maxCommentLength
    * @param {number} skip
    * @param {number} top
    */
    GitApi.prototype.getPullRequests = function (repositoryId, searchCriteria, project, maxCommentLength, skip, top) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequests) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequests);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            searchCriteria: searchCriteria,
            maxCommentLength: maxCommentLength,
            '$skip': skip,
            '$top': top,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "9946fd70-0d40-406e-b686-b4744cbbcc37", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitPullRequest, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Updates a pull request
    *
    * @param {GitInterfaces.GitPullRequest} gitPullRequestToUpdate
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.updatePullRequest = function (gitPullRequestToUpdate, repositoryId, pullRequestId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequest) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequest);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "9946fd70-0d40-406e-b686-b4744cbbcc37", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: GitInterfaces.TypeInfo.GitPullRequest, responseTypeMetadata: GitInterfaces.TypeInfo.GitPullRequest, responseIsCollection: false };
            _this.restClient.update(url, apiVersion, gitPullRequestToUpdate, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Create a pull request iteration status
    *
    * @param {GitInterfaces.GitPullRequestStatus} status
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {number} iterationId
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.createPullRequestIterationStatus = function (status, repositoryId, pullRequestId, iterationId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequestStatuse) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestStatuse);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId,
            iterationId: iterationId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "75cf11c5-979f-4038-a76e-058a06adf2bf", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: GitInterfaces.TypeInfo.GitPullRequestStatus, responseTypeMetadata: GitInterfaces.TypeInfo.GitPullRequestStatus, responseIsCollection: false };
            _this.restClient.create(url, apiVersion, status, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Get the specific pull request iteration status.
    *
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {number} iterationId
    * @param {number} statusId
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.getPullRequestIterationStatus = function (repositoryId, pullRequestId, iterationId, statusId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequestStatuse) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestStatuse);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId,
            iterationId: iterationId,
            statusId: statusId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "75cf11c5-979f-4038-a76e-058a06adf2bf", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitPullRequestStatus, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Get all the statuses associated with a pull request iteration.
    *
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {number} iterationId
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.getPullRequestIterationStatuses = function (repositoryId, pullRequestId, iterationId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequestStatuses) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestStatuses);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId,
            iterationId: iterationId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "75cf11c5-979f-4038-a76e-058a06adf2bf", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitPullRequestStatus, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Create a pull request status
    *
    * @param {GitInterfaces.GitPullRequestStatus} status
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.createPullRequestStatus = function (status, repositoryId, pullRequestId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequestStatuse) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestStatuse);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "b5f6bb4f-8d1e-4d79-8d11-4c9172c99c35", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: GitInterfaces.TypeInfo.GitPullRequestStatus, responseTypeMetadata: GitInterfaces.TypeInfo.GitPullRequestStatus, responseIsCollection: false };
            _this.restClient.create(url, apiVersion, status, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Get the specific pull request status.
    *
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {number} statusId
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.getPullRequestStatus = function (repositoryId, pullRequestId, statusId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequestStatuse) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestStatuse);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId,
            statusId: statusId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "b5f6bb4f-8d1e-4d79-8d11-4c9172c99c35", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitPullRequestStatus, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Get all the statuses associated with a pull request.
    *
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.getPullRequestStatuses = function (repositoryId, pullRequestId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequestStatuses) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestStatuses);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "b5f6bb4f-8d1e-4d79-8d11-4c9172c99c35", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitPullRequestStatus, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Create a pull request review comment
    *
    * @param {GitInterfaces.Comment} comment
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {number} threadId
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.createComment = function (comment, repositoryId, pullRequestId, threadId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequestThreadComment) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestThreadComment);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId,
            threadId: threadId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "965a3ec7-5ed8-455a-bdcb-835a5ea7fe7b", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: GitInterfaces.TypeInfo.Comment, responseTypeMetadata: GitInterfaces.TypeInfo.Comment, responseIsCollection: false };
            _this.restClient.create(url, apiVersion, comment, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Delete a pull request comment by id for a pull request
    *
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {number} threadId
    * @param {number} commentId
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.deleteComment = function (repositoryId, pullRequestId, threadId, commentId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(null);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId,
            threadId: threadId,
            commentId: commentId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "965a3ec7-5ed8-455a-bdcb-835a5ea7fe7b", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: false };
            _this.restClient.delete(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode);
        });
        return deferred.promise;
    };
    /**
    * Get a pull request comment by id for a pull request
    *
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {number} threadId
    * @param {number} commentId
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.getComment = function (repositoryId, pullRequestId, threadId, commentId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequestThreadComment) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestThreadComment);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId,
            threadId: threadId,
            commentId: commentId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "965a3ec7-5ed8-455a-bdcb-835a5ea7fe7b", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.Comment, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Get all pull request comments in a thread.
    *
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {number} threadId
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.getComments = function (repositoryId, pullRequestId, threadId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequestThreadComments) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestThreadComments);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId,
            threadId: threadId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "965a3ec7-5ed8-455a-bdcb-835a5ea7fe7b", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.Comment, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Update a pull request review comment thread
    *
    * @param {GitInterfaces.Comment} comment
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {number} threadId
    * @param {number} commentId
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.updateComment = function (comment, repositoryId, pullRequestId, threadId, commentId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequestThreadComment) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestThreadComment);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId,
            threadId: threadId,
            commentId: commentId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "965a3ec7-5ed8-455a-bdcb-835a5ea7fe7b", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: GitInterfaces.TypeInfo.Comment, responseTypeMetadata: GitInterfaces.TypeInfo.Comment, responseIsCollection: false };
            _this.restClient.update(url, apiVersion, comment, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Create a pull request review comment thread
    *
    * @param {GitInterfaces.GitPullRequestCommentThread} commentThread
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.createThread = function (commentThread, repositoryId, pullRequestId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequestThread) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestThread);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "ab6e2e5d-a0b7-4153-b64a-a4efe0d49449", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: GitInterfaces.TypeInfo.GitPullRequestCommentThread, responseTypeMetadata: GitInterfaces.TypeInfo.GitPullRequestCommentThread, responseIsCollection: false };
            _this.restClient.create(url, apiVersion, commentThread, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Get a pull request comment thread by id for a pull request
    *
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {number} threadId
    * @param {string} project - Project ID or project name
    * @param {number} iteration
    * @param {number} baseIteration
    */
    GitApi.prototype.getPullRequestThread = function (repositoryId, pullRequestId, threadId, project, iteration, baseIteration) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequestThread) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestThread);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId,
            threadId: threadId
        };
        var queryValues = {
            '$iteration': iteration,
            '$baseIteration': baseIteration,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "ab6e2e5d-a0b7-4153-b64a-a4efe0d49449", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitPullRequestCommentThread, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Get all pull request comment threads.
    *
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {string} project - Project ID or project name
    * @param {number} iteration
    * @param {number} baseIteration
    */
    GitApi.prototype.getThreads = function (repositoryId, pullRequestId, project, iteration, baseIteration) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequestThreads) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestThreads);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId
        };
        var queryValues = {
            '$iteration': iteration,
            '$baseIteration': baseIteration,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "ab6e2e5d-a0b7-4153-b64a-a4efe0d49449", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitPullRequestCommentThread, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Update a pull request review comment thread
    *
    * @param {GitInterfaces.GitPullRequestCommentThread} commentThread
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {number} threadId
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.updateThread = function (commentThread, repositoryId, pullRequestId, threadId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequestThread) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestThread);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId,
            threadId: threadId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "ab6e2e5d-a0b7-4153-b64a-a4efe0d49449", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: GitInterfaces.TypeInfo.GitPullRequestCommentThread, responseTypeMetadata: GitInterfaces.TypeInfo.GitPullRequestCommentThread, responseIsCollection: false };
            _this.restClient.update(url, apiVersion, commentThread, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Retrieve a pull request work items
    *
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.getPullRequestWorkItems = function (repositoryId, pullRequestId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, PullRequestWorkItems) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestWorkItems);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "0a637fcc-5370-4ce8-b0e8-98091f5f9482", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Push changes to the repository.
    *
    * @param {GitInterfaces.GitPush} push
    * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, a project-scoped route must be used.
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.createPush = function (push, repositoryId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, pushe) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(pushe);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        this.vsoClient.getVersioningData("3.1-preview.2", "git", "ea98d07b-3c87-4971-8ede-a613694ffb55", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: GitInterfaces.TypeInfo.GitPush, responseTypeMetadata: GitInterfaces.TypeInfo.GitPush, responseIsCollection: false };
            _this.restClient.create(url, apiVersion, push, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Retrieve a particular push.
    *
    * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
    * @param {number} pushId - The id of the push.
    * @param {string} project - Project ID or project name
    * @param {number} includeCommits - The number of commits to include in the result.
    * @param {boolean} includeRefUpdates
    */
    GitApi.prototype.getPush = function (repositoryId, pushId, project, includeCommits, includeRefUpdates) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, pushe) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(pushe);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pushId: pushId
        };
        var queryValues = {
            includeCommits: includeCommits,
            includeRefUpdates: includeRefUpdates,
        };
        this.vsoClient.getVersioningData("3.1-preview.2", "git", "ea98d07b-3c87-4971-8ede-a613694ffb55", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitPush, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Retrieves pushes associated with the specified repository.
    *
    * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
    * @param {string} project - Project ID or project name
    * @param {number} skip
    * @param {number} top
    * @param {GitInterfaces.GitPushSearchCriteria} searchCriteria
    */
    GitApi.prototype.getPushes = function (repositoryId, project, skip, top, searchCriteria) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, pushes) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(pushes);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            '$skip': skip,
            '$top': top,
            searchCriteria: searchCriteria,
        };
        this.vsoClient.getVersioningData("3.1-preview.2", "git", "ea98d07b-3c87-4971-8ede-a613694ffb55", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitPush, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Lock or unlock a ref.
    *
    * @param {GitInterfaces.GitRefLockRequest} refLockRequest
    * @param {string} project - Project ID or project name
    * @param {string} repositoryId
    */
    GitApi.prototype.createRefLockRequest = function (refLockRequest, project, repositoryId) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(null);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "32863ac0-6a8a-4d9f-8afe-ba293b93ec3c", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: false };
            _this.restClient.create(url, apiVersion, refLockRequest, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode);
        });
        return deferred.promise;
    };
    /**
    * Queries the provided repository for its refs and returns them.
    *
    * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
    * @param {string} project - Project ID or project name
    * @param {string} filter - [optional] A filter to apply to the refs.
    * @param {boolean} includeLinks - [optional] Specifies if referenceLinks should be included in the result. default is false.
    * @param {boolean} latestStatusesOnly
    */
    GitApi.prototype.getRefs = function (repositoryId, project, filter, includeLinks, latestStatusesOnly) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, refs) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(refs);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            filter: filter,
            includeLinks: includeLinks,
            latestStatusesOnly: latestStatusesOnly,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "2d874a60-a811-4f62-9c9f-963a6ea0a55b", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitRef, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Creates or updates refs with the given information
    *
    * @param {GitInterfaces.GitRefUpdate[]} refUpdates - List of ref updates to attempt to perform
    * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
    * @param {string} project - Project ID or project name
    * @param {string} projectId - The id of the project.
    */
    GitApi.prototype.updateRefs = function (refUpdates, repositoryId, project, projectId) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, refs) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(refs);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            projectId: projectId,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "2d874a60-a811-4f62-9c9f-963a6ea0a55b", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitRefUpdateResult, responseIsCollection: true };
            _this.restClient.create(url, apiVersion, refUpdates, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Creates a ref favorite
    *
    * @param {GitInterfaces.GitRefFavorite} favorite
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.createFavorite = function (favorite, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, refsFavorite) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(refsFavorite);
            }
        };
        var routeValues = {
            project: project
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "876f70af-5792-485a-a1c7-d0a7b2f42bbb", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: GitInterfaces.TypeInfo.GitRefFavorite, responseTypeMetadata: GitInterfaces.TypeInfo.GitRefFavorite, responseIsCollection: false };
            _this.restClient.create(url, apiVersion, favorite, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * @param {string} project - Project ID or project name
    * @param {number} favoriteId
    */
    GitApi.prototype.deleteRefFavorite = function (project, favoriteId) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(null);
            }
        };
        var routeValues = {
            project: project,
            favoriteId: favoriteId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "876f70af-5792-485a-a1c7-d0a7b2f42bbb", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: false };
            _this.restClient.delete(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode);
        });
        return deferred.promise;
    };
    /**
    * @param {string} project - Project ID or project name
    * @param {number} favoriteId
    */
    GitApi.prototype.getRefFavorite = function (project, favoriteId) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, refsFavorite) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(refsFavorite);
            }
        };
        var routeValues = {
            project: project,
            favoriteId: favoriteId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "876f70af-5792-485a-a1c7-d0a7b2f42bbb", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitRefFavorite, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Gets the refs favorites for a repo and an identity.
    *
    * @param {string} project - Project ID or project name
    * @param {string} repositoryId - The id of the repository.
    * @param {string} identityId - The id of the identity whose favorites are to be retrieved. If null, the requesting identity is used.
    */
    GitApi.prototype.getRefFavorites = function (project, repositoryId, identityId) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, refsFavorites) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(refsFavorites);
            }
        };
        var routeValues = {
            project: project
        };
        var queryValues = {
            repositoryId: repositoryId,
            identityId: identityId,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "876f70af-5792-485a-a1c7-d0a7b2f42bbb", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitRefFavorite, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Create a git repository
    *
    * @param {GitInterfaces.GitRepository} gitRepositoryToCreate
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.createRepository = function (gitRepositoryToCreate, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, Repositorie) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Repositorie);
            }
        };
        var routeValues = {
            project: project
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "225f7195-f9c7-4d14-ab28-a83f7ff77e1f", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: false };
            _this.restClient.create(url, apiVersion, gitRepositoryToCreate, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Delete a git repository
    *
    * @param {string} repositoryId
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.deleteRepository = function (repositoryId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(null);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "225f7195-f9c7-4d14-ab28-a83f7ff77e1f", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: false };
            _this.restClient.delete(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode);
        });
        return deferred.promise;
    };
    /**
    * Retrieve git repositories.
    *
    * @param {string} project - Project ID or project name
    * @param {boolean} includeLinks
    * @param {boolean} includeAllUrls
    */
    GitApi.prototype.getRepositories = function (project, includeLinks, includeAllUrls) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, Repositories) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Repositories);
            }
        };
        var routeValues = {
            project: project
        };
        var queryValues = {
            includeLinks: includeLinks,
            includeAllUrls: includeAllUrls,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "225f7195-f9c7-4d14-ab28-a83f7ff77e1f", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * @param {string} repositoryId
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.getRepository = function (repositoryId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, Repositorie) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Repositorie);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "225f7195-f9c7-4d14-ab28-a83f7ff77e1f", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Updates the Git repository with the single populated change in the specified repository information.
    *
    * @param {GitInterfaces.GitRepository} newRepositoryInfo
    * @param {string} repositoryId
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.updateRepository = function (newRepositoryInfo, repositoryId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, Repositorie) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Repositorie);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "225f7195-f9c7-4d14-ab28-a83f7ff77e1f", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: false };
            _this.restClient.update(url, apiVersion, newRepositoryInfo, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * @param {GitInterfaces.GitAsyncRefOperationParameters} revertToCreate
    * @param {string} project - Project ID or project name
    * @param {string} repositoryId
    */
    GitApi.prototype.createRevert = function (revertToCreate, project, repositoryId) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, Revert) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Revert);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "bc866058-5449-4715-9cf1-a510b6ff193c", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: GitInterfaces.TypeInfo.GitAsyncRefOperationParameters, responseTypeMetadata: GitInterfaces.TypeInfo.GitRevert, responseIsCollection: false };
            _this.restClient.create(url, apiVersion, revertToCreate, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * @param {string} project - Project ID or project name
    * @param {number} revertId
    * @param {string} repositoryId
    */
    GitApi.prototype.getRevert = function (project, revertId, repositoryId) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, Revert) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Revert);
            }
        };
        var routeValues = {
            project: project,
            revertId: revertId,
            repositoryId: repositoryId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "bc866058-5449-4715-9cf1-a510b6ff193c", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitRevert, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * @param {string} project - Project ID or project name
    * @param {string} repositoryId
    * @param {string} refName
    */
    GitApi.prototype.getRevertForRefName = function (project, repositoryId, refName) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, Revert) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Revert);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            refName: refName,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "bc866058-5449-4715-9cf1-a510b6ff193c", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitRevert, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * @param {GitInterfaces.GitStatus} gitCommitStatusToCreate
    * @param {string} commitId
    * @param {string} repositoryId
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.createCommitStatus = function (gitCommitStatusToCreate, commitId, repositoryId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, Statuse) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Statuse);
            }
        };
        var routeValues = {
            project: project,
            commitId: commitId,
            repositoryId: repositoryId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "428dd4fb-fda5-4722-af02-9313b80305da", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: GitInterfaces.TypeInfo.GitStatus, responseTypeMetadata: GitInterfaces.TypeInfo.GitStatus, responseIsCollection: false };
            _this.restClient.create(url, apiVersion, gitCommitStatusToCreate, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * @param {string} commitId
    * @param {string} repositoryId
    * @param {string} project - Project ID or project name
    * @param {number} top
    * @param {number} skip
    * @param {boolean} latestOnly
    */
    GitApi.prototype.getStatuses = function (commitId, repositoryId, project, top, skip, latestOnly) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, Statuses) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Statuses);
            }
        };
        var routeValues = {
            project: project,
            commitId: commitId,
            repositoryId: repositoryId
        };
        var queryValues = {
            top: top,
            skip: skip,
            latestOnly: latestOnly,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "428dd4fb-fda5-4722-af02-9313b80305da", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitStatus, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * Retrieve a set of suggestions (including a pull request suggestion).
    *
    * @param {string} repositoryId
    * @param {string} project - Project ID or project name
    */
    GitApi.prototype.getSuggestions = function (repositoryId, project) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, Suggestions) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Suggestions);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "9393b4fb-4445-4919-972b-9ad16f442d83", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * @param {string} repositoryId
    * @param {string} sha1
    * @param {string} project - Project ID or project name
    * @param {string} projectId
    * @param {boolean} recursive
    * @param {string} fileName
    */
    GitApi.prototype.getTree = function (repositoryId, sha1, project, projectId, recursive, fileName) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, Tree) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Tree);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            sha1: sha1
        };
        var queryValues = {
            projectId: projectId,
            recursive: recursive,
            fileName: fileName,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "729f6437-6f92-44ec-8bee-273a7111063c", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitTreeRef, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * @param {string} repositoryId
    * @param {string} sha1
    * @param {string} project - Project ID or project name
    * @param {string} projectId
    * @param {boolean} recursive
    * @param {string} fileName
    */
    GitApi.prototype.getTreeZip = function (repositoryId, sha1, project, projectId, recursive, fileName) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, Tree) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Tree);
            }
        };
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            sha1: sha1
        };
        var queryValues = {
            projectId: projectId,
            recursive: recursive,
            fileName: fileName,
        };
        this.vsoClient.getVersioningData("3.1-preview.1", "git", "729f6437-6f92-44ec-8bee-273a7111063c", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: false };
            _this.httpClient.getStream(url, apiVersion, "application/zip", onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    return GitApi;
}(basem.ClientApiBase));
exports.GitApi = GitApi;
