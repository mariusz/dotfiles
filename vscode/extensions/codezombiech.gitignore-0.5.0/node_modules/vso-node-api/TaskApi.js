/*
* ---------------------------------------------------------
* Copyright(C) Microsoft Corporation. All rights reserved.
* ---------------------------------------------------------
*
* ---------------------------------------------------------
* Generated file, DO NOT EDIT
* ---------------------------------------------------------
*/
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
// Licensed under the MIT license.  See LICENSE file in the project root for full license information.
var Q = require('q');
var basem = require('./ClientApiBases');
var TaskAgentInterfaces = require("./interfaces/TaskAgentInterfaces");
var TaskApi = (function (_super) {
    __extends(TaskApi, _super);
    function TaskApi(baseUrl, handlers) {
        _super.call(this, baseUrl, handlers, 'node-Task-api');
    }
    /**
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    * @param {string} type
    */
    TaskApi.prototype.getPlanAttachments = function (scopeIdentifier, hubName, planId, type) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, attachments) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(attachments);
            }
        };
        var routeValues = {
            scopeIdentifier: scopeIdentifier,
            hubName: hubName,
            planId: planId,
            type: type
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "distributedtask", "eb55e5d6-2f30-4295-b5ed-38da50b1fc52", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: TaskAgentInterfaces.TypeInfo.TaskAttachment, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * @param {NodeJS.ReadableStream} contentStream - Content to upload
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    * @param {string} timelineId
    * @param {string} recordId
    * @param {string} type
    * @param {string} name
    */
    TaskApi.prototype.createAttachment = function (customHeaders, contentStream, scopeIdentifier, hubName, planId, timelineId, recordId, type, name) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, attachment) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(attachment);
            }
        };
        var routeValues = {
            scopeIdentifier: scopeIdentifier,
            hubName: hubName,
            planId: planId,
            timelineId: timelineId,
            recordId: recordId,
            type: type,
            name: name
        };
        customHeaders = customHeaders || {};
        customHeaders["Content-Type"] = "application/octet-stream";
        this.vsoClient.getVersioningData("3.0-preview.1", "distributedtask", "7898f959-9cdf-4096-b29e-7f293031629e", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: TaskAgentInterfaces.TypeInfo.TaskAttachment, responseIsCollection: false };
            _this.restClient.uploadStream('PUT', url, apiVersion, contentStream, customHeaders, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    * @param {string} timelineId
    * @param {string} recordId
    * @param {string} type
    * @param {string} name
    */
    TaskApi.prototype.getAttachment = function (scopeIdentifier, hubName, planId, timelineId, recordId, type, name) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, attachment) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(attachment);
            }
        };
        var routeValues = {
            scopeIdentifier: scopeIdentifier,
            hubName: hubName,
            planId: planId,
            timelineId: timelineId,
            recordId: recordId,
            type: type,
            name: name
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "distributedtask", "7898f959-9cdf-4096-b29e-7f293031629e", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: TaskAgentInterfaces.TypeInfo.TaskAttachment, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    * @param {string} timelineId
    * @param {string} recordId
    * @param {string} type
    * @param {string} name
    */
    TaskApi.prototype.getAttachmentContent = function (scopeIdentifier, hubName, planId, timelineId, recordId, type, name) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, attachment) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(attachment);
            }
        };
        var routeValues = {
            scopeIdentifier: scopeIdentifier,
            hubName: hubName,
            planId: planId,
            timelineId: timelineId,
            recordId: recordId,
            type: type,
            name: name
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "distributedtask", "7898f959-9cdf-4096-b29e-7f293031629e", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: false };
            _this.httpClient.getStream(url, apiVersion, "application/octet-stream", onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    * @param {string} timelineId
    * @param {string} recordId
    * @param {string} type
    */
    TaskApi.prototype.getAttachments = function (scopeIdentifier, hubName, planId, timelineId, recordId, type) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, attachments) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(attachments);
            }
        };
        var routeValues = {
            scopeIdentifier: scopeIdentifier,
            hubName: hubName,
            planId: planId,
            timelineId: timelineId,
            recordId: recordId,
            type: type
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "distributedtask", "7898f959-9cdf-4096-b29e-7f293031629e", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: TaskAgentInterfaces.TypeInfo.TaskAttachment, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * @param {VSSInterfaces.VssJsonCollectionWrapperV<string[]>} lines
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    * @param {string} timelineId
    * @param {string} recordId
    */
    TaskApi.prototype.appendTimelineRecordFeed = function (lines, scopeIdentifier, hubName, planId, timelineId, recordId) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(null);
            }
        };
        var routeValues = {
            scopeIdentifier: scopeIdentifier,
            hubName: hubName,
            planId: planId,
            timelineId: timelineId,
            recordId: recordId
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "distributedtask", "858983e4-19bd-4c5e-864c-507b59b58b12", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: false };
            _this.restClient.create(url, apiVersion, lines, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode);
        });
        return deferred.promise;
    };
    /**
    * @param {NodeJS.ReadableStream} contentStream - Content to upload
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    * @param {number} logId
    */
    TaskApi.prototype.appendLogContent = function (customHeaders, contentStream, scopeIdentifier, hubName, planId, logId) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, log) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(log);
            }
        };
        var routeValues = {
            scopeIdentifier: scopeIdentifier,
            hubName: hubName,
            planId: planId,
            logId: logId
        };
        customHeaders = customHeaders || {};
        customHeaders["Content-Type"] = "application/octet-stream";
        this.vsoClient.getVersioningData("3.0-preview.1", "distributedtask", "46f5667d-263a-4684-91b1-dff7fdcf64e2", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: TaskAgentInterfaces.TypeInfo.TaskLog, responseIsCollection: false };
            _this.restClient.uploadStream('POST', url, apiVersion, contentStream, customHeaders, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * @param {TaskAgentInterfaces.TaskLog} log
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    */
    TaskApi.prototype.createLog = function (log, scopeIdentifier, hubName, planId) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, log) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(log);
            }
        };
        var routeValues = {
            scopeIdentifier: scopeIdentifier,
            hubName: hubName,
            planId: planId
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "distributedtask", "46f5667d-263a-4684-91b1-dff7fdcf64e2", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: TaskAgentInterfaces.TypeInfo.TaskLog, responseTypeMetadata: TaskAgentInterfaces.TypeInfo.TaskLog, responseIsCollection: false };
            _this.restClient.create(url, apiVersion, log, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    * @param {number} logId
    * @param {number} startLine
    * @param {number} endLine
    */
    TaskApi.prototype.getLog = function (scopeIdentifier, hubName, planId, logId, startLine, endLine) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, logs) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(logs);
            }
        };
        var routeValues = {
            scopeIdentifier: scopeIdentifier,
            hubName: hubName,
            planId: planId,
            logId: logId
        };
        var queryValues = {
            startLine: startLine,
            endLine: endLine,
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "distributedtask", "46f5667d-263a-4684-91b1-dff7fdcf64e2", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    */
    TaskApi.prototype.getLogs = function (scopeIdentifier, hubName, planId) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, logs) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(logs);
            }
        };
        var routeValues = {
            scopeIdentifier: scopeIdentifier,
            hubName: hubName,
            planId: planId
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "distributedtask", "46f5667d-263a-4684-91b1-dff7fdcf64e2", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: TaskAgentInterfaces.TypeInfo.TaskLog, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    */
    TaskApi.prototype.getPlan = function (scopeIdentifier, hubName, planId) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, plan) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(plan);
            }
        };
        var routeValues = {
            scopeIdentifier: scopeIdentifier,
            hubName: hubName,
            planId: planId
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "distributedtask", "5cecd946-d704-471e-a45f-3b4064fcfaba", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: TaskAgentInterfaces.TypeInfo.TaskOrchestrationPlan, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    * @param {string} timelineId
    * @param {number} changeId
    */
    TaskApi.prototype.getRecords = function (scopeIdentifier, hubName, planId, timelineId, changeId) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, records) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(records);
            }
        };
        var routeValues = {
            scopeIdentifier: scopeIdentifier,
            hubName: hubName,
            planId: planId,
            timelineId: timelineId
        };
        var queryValues = {
            changeId: changeId,
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "distributedtask", "8893bc5b-35b2-4be7-83cb-99e683551db4", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: TaskAgentInterfaces.TypeInfo.TimelineRecord, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * @param {VSSInterfaces.VssJsonCollectionWrapperV<TaskAgentInterfaces.TimelineRecord[]>} records
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    * @param {string} timelineId
    */
    TaskApi.prototype.updateRecords = function (records, scopeIdentifier, hubName, planId, timelineId) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, record) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(record);
            }
        };
        var routeValues = {
            scopeIdentifier: scopeIdentifier,
            hubName: hubName,
            planId: planId,
            timelineId: timelineId
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "distributedtask", "8893bc5b-35b2-4be7-83cb-99e683551db4", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: TaskAgentInterfaces.TypeInfo.TimelineRecord, responseIsCollection: true };
            _this.restClient.update(url, apiVersion, records, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * @param {TaskAgentInterfaces.Timeline} timeline
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    */
    TaskApi.prototype.createTimeline = function (timeline, scopeIdentifier, hubName, planId) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, timeline) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(timeline);
            }
        };
        var routeValues = {
            scopeIdentifier: scopeIdentifier,
            hubName: hubName,
            planId: planId
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "distributedtask", "83597576-cc2c-453c-bea6-2882ae6a1653", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: TaskAgentInterfaces.TypeInfo.Timeline, responseTypeMetadata: TaskAgentInterfaces.TypeInfo.Timeline, responseIsCollection: false };
            _this.restClient.create(url, apiVersion, timeline, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    * @param {string} timelineId
    */
    TaskApi.prototype.deleteTimeline = function (scopeIdentifier, hubName, planId, timelineId) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(null);
            }
        };
        var routeValues = {
            scopeIdentifier: scopeIdentifier,
            hubName: hubName,
            planId: planId,
            timelineId: timelineId
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "distributedtask", "83597576-cc2c-453c-bea6-2882ae6a1653", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: false };
            _this.restClient.delete(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode);
        });
        return deferred.promise;
    };
    /**
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    * @param {string} timelineId
    * @param {number} changeId
    * @param {boolean} includeRecords
    */
    TaskApi.prototype.getTimeline = function (scopeIdentifier, hubName, planId, timelineId, changeId, includeRecords) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, timeline) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(timeline);
            }
        };
        var routeValues = {
            scopeIdentifier: scopeIdentifier,
            hubName: hubName,
            planId: planId,
            timelineId: timelineId
        };
        var queryValues = {
            changeId: changeId,
            includeRecords: includeRecords,
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "distributedtask", "83597576-cc2c-453c-bea6-2882ae6a1653", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: TaskAgentInterfaces.TypeInfo.Timeline, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    /**
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    */
    TaskApi.prototype.getTimelines = function (scopeIdentifier, hubName, planId) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, timelines) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(timelines);
            }
        };
        var routeValues = {
            scopeIdentifier: scopeIdentifier,
            hubName: hubName,
            planId: planId
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "distributedtask", "83597576-cc2c-453c-bea6-2882ae6a1653", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: TaskAgentInterfaces.TypeInfo.Timeline, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    return TaskApi;
}(basem.ClientApiBase));
exports.TaskApi = TaskApi;
